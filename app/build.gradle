plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-kapt'
    // 由于Dagger上手比较困难，所以Google基于Dagger自己开发了一套依赖注入框架: Hilt，也是Jetpack中其中一个组件
    id 'dagger.hilt.android.plugin'
    id("com.google.devtools.ksp")

}
// Android 自带的代码覆盖率检测工具
//apply plugin: 'jacoco'
//jacoco {
//    toolVersion = "0.8.5"
//}


android {

    namespace 'com.simley.ndk_day78'
    compileSdk rootProject.android.compileSdk

    defaultConfig {
        applicationId rootProject.android.applicationId
        minSdk rootProject.android.minSdk
        targetSdk rootProject.android.targetSdk
        versionCode rootProject.android.versionCode
        versionName rootProject.android.versionName

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        multiDexEnabled true

        externalNativeBuild {
            cmake {
                /*
                cppFlags

                 */
                cppFlags '-std=c++11'
                /*
                arguments
                    Gradle从远端下载libc++-shared.so库
                    因为高版本的android系统已经删掉了这个.so库貌似
                    如果没有这个库，但是又刚好用到那么会报错
                 */
                arguments '-DANDROID_STL=c++_static'
                /*
                abiFilters：指定CPU架构，cmake的本地库，例如：native-lib
                    如果是abiFilters ''，则默认生成所有CPU架构的文件
                 */
                rootProject.abiFilters.each { abi -> abiFilters abi }
            }
        }

        // 指定CPU架构，指定了之后才真正将lib/CPU架构(arm64-v8a) 打包进APK包
        ndk {
            /*
                设置支持的SO库架构
                目前手机支持的主流的CPU架构就是arm64-v8a
                armeabi-v7a出现在一些老的设备机型，或者是一些IOT设备中，在目前智能手机产品中，这种CPU架构已逐渐被淘汰
                x86和x86_64一般是模拟器所使用的CPU架构，或者当年的微软的Windows Phone
                x86和arm的区别：
                    x86是复杂指令集
                    arm是简单指令集
                    x86相对于arm来说性能更好，但是更耗电，arm则相反

                ===================================================================================================
                ABI（横向）和cpu（纵向）	armeabi	    armeabi-v7a	    arm64-v8a	mips	mips64	    x86	    x86_64
                ARMv5	                  支持
                ARMv7	                  支持	        支持
                ARMv8	                  支持	        支持	        支持
                MIPS	 	 	 	                                            支持
                MIPS64	 	 	 	                                            支持	      支持
                x86	                    支持（3）	        支持（2）	 	 	 	                       支持（1）
                x86_64	                  支持	 	 	 	 	                                    支持	  支持
                ===================================================================================================
             */
            // abiFilters 'arm64-v8a'//, 'x86', 'armeabi-v7a', 'x86_64'
            rootProject.abiFilters.each { abi -> abiFilters abi }
        }
    }
    // 项目构建类型
    buildTypes {
        // 发布版配置
        release {
<<<<<<< HEAD
            // 是否开启混淆
            minifyEnabled true
            // 压缩资源
            shrinkResources true
            // 混淆规则
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            // Java代码是否可以调试
            debuggable false
            // Jni代码是否可以调试
            jniDebuggable false
            // zipAlignEnabled true
        }
        // 测试版配置
        debug {
            minifyEnabled false
            shrinkResources false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            debuggable true
            jniDebuggable true
=======
            // 代码删减。在 R8 编译中，编译器会通过方法的可达分析来检测方法是否被使用到，如果没被使用到，就会在编译过程中被删减
            // 开启 R8 很简单，只需要在 build.gradle 中将 minifyEnabled 属性设为 true 即可
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            // testCoverageEnabled = true
>>>>>>> 12452e2 (优化gradle配置，提高构建速度)
        }
        // debug {
        // }
    }
<<<<<<< HEAD
    // 使用JDK 1.8进行编译
=======


>>>>>>> 12452e2 (优化gradle配置，提高构建速度)
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    externalNativeBuild {
        cmake {
            path file('src/main/cpp/CMakeLists.txt')
            version '3.18.1'
        }
    }
    buildFeatures {
        viewBinding true        // 在这里开启了Jetpack的ViewBinding组件
        aidl true
    }
    sourceSets {
        main {
            jniLibs.srcDirs = ['src/main/cpp/libs']
        }
    }
    lint {
        abortOnError false
    }
    packagingOptions {
        jniLibs {
            useLegacyPackaging true
        }
    }
}

//project.afterEvaluate {
//    project.plugins.withId("com.android.application") { AppPlugin p ->
//        p.getVariantManager().getVariantScopes().each { VariantScope scope ->
//
//            // 1. 寻找 packageTask
//            def packageTask = project.tasks.findByName("package${scope.fullVariantName.capitalize()}")
//
//            if (packageTask != null) {
//                // 在 packageTask 之前执行 so 的压缩
//                packageTask.doFirst {
//                    // 获取 jni 目录中的 so文件
//                    FileCollection soFiles = scope
//                            .getTransformManager()
//                            .getPipelineOutputAsFileCollection(StreamFilter.NATIVE_LIBS)
//                    // 获取 assets 文件，用来存放压缩后的 so
//                    File assetsFile = scope
//                            .getArtifacts()
//                            .getFinalArtifactFiles(InternalArtifactType.MERGED_ASSETS)
//                            .getFiles().iterator().next();
//
//                    //2. 压缩 so
//                    doSoCompress(soFiles, assetsFile)
//                }
//            }
//        }
//    }
//}
//
//private void doSoCompress(Set<File> soFiles, File assetsFile) {
//    // 遍历 jni 文件中的 so ，并进行压缩和删除处理
//    try {
//        for (File f : soFiles) {
//            FileInputStream input = new FileInputStream(f);
//            // 压缩成 .so 后缀结尾的文件，并放在 asset目录下
//            FileOutputStream outputStream = new FileOutputStream(assetsFile.getAbsolutePath() +
//                    File.separator + f.getName().substring(0, filename.indexOf('.')) + ".so");
//
//            // 调用 zstd 的 api 进行压缩。
//            ZstdOutputStream output = new ZstdOutputStream(outputStream, 19);
//            IOUtils.copy(input, output);
//
//            output.flush();
//            output.close();
//            outputStream.close();
//            input.close();
//        }
//    } catch (FileNotFoundException e) {
//        e.printStackTrace();
//    } catch (IOException e) {
//        e.printStackTrace();
//    }
//
//    // 删除原 so 文件
//    Arrays.asList(soFiles).stream().forEach(File::delete);
//}


// TODO 以下是一些脚本，后续可以拆分到别的gradle文件中

dependencies {

    implementation files("libs\\fmod.jar")
    implementation project(path: ':lib_rtmp')

    // facebook 开源的压缩算法 ztsd
    // 这个是有人已经集成好了的，如果使用官方的还得自己编译
    implementation "com.github.luben:zstd-jni:1.5.5-1@aar"

    println('===================开始聚合所需模块===================')
    int orderNum = 1
    rootProject.projectsPath.each { path ->
        println("【Module ${orderNum++}】：${path} ")
        implementation project(path: ':' + path)
    }

    println("===================开始聚合所需依赖===================")
    orderNum = 1
    rootProject.deps.each { k, v ->
        println("【Dependency ${orderNum++}】：${k}")
        implementation v
    }

    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10'
    kapt 'com.google.dagger:hilt-android-compiler:2.41'
    testImplementation 'junit:junit:4.13.2'
}